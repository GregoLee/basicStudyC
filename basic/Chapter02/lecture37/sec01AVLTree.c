//
// Created by Jaeyoung Lee on 2020/04/08.
//
/*
 * AVL 트리
 * 1. 개요
 *    1) AVL트리는 균형이 갖춰진 이진 트리(Binary Tree)를 의미한다.
 *    2) 완전 이진 트리는 검색에 있어서 O(log N)의 시간 복잡도를 유지할 수 있다.
 *    3) AVL트리는 간단한 구현 과정으로 특정 이진 트리가 완전 이진 트리에 가까운 형태를 유지하도록 해준다.
 *       - 균형 인수(Balance Factor)라는 개념을 이용
 *         ; 균형 인수 = | 왼쪽 자식 높이 - 오른쪽 자식 높이 |
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                      1                      0
 *               ┏━━━━━┛ ┗━━━━━┓        ┏━━━━━┛ ┗━━━━━┓
 *               0             0        0             0
 *           ┏━━┛ ┗━━┓
 *           0       0
 *       - 모든 노드에 대한 균형 인수가 +1, 0, -1인 트리를 의미한다.
 *       - 균형 인수가 위 세가지 경우에 해당하지 않는 경우 '회전(Rotation)'을 통해 트리를 재구성해야 한다.
 *
 * 2. AVL트리의 회전
 *    ; 총 4가지의 형식에 의하여 균형이 깨질 수 있다. 균형 인수가 깨지는 노드를 X라고 했을 때 4가지 형식은 다음과 같다.
 *       1) LL 형식 : X의 왼쪽 자식의 왼쪽에 삽입하는 경우우
 *          - 회전 조건
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                      1                      0
 *               ┏━━━━━┛                ┏━━━━━┛ ┗━━━━━┓
 *               0                      0             0
 *
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                      2                      0
 *               ┏━━━━━┛                ┏━━━━━┛ ┗━━━━━┓
 *               1                      0             0
 *           ┏━━┛
 *           0
 *
 *       2) LR 형식 : X의 왼쪽 자식의 오른쪽에 삽입하는 경우
 *          - 회전 조건
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                      1                      0
 *               ┏━━━━━┛                ┏━━━━━┛ ┗━━━━━┓
 *               0                      0             0
 *
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                      2                      0
 *               ┏━━━━━┛                ┏━━━━━┛ ┗━━━━━┓
 *              -1                      0             0
 *               ┗━━┓
 *                  0
 *
 *       3) RR 형식 : X의 오른쪽 자식의 오른쪽에 삽입하는 경우
 *          - 회전 조건
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                     -1                      0
 *                      ┗━━━━━┓         ┏━━━━━┛ ┗━━━━━┓
 *                            0         0             0
 *
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                     -2                      0
 *                      ┗━━━━━┓         ┏━━━━━┛ ┗━━━━━┓
 *                           -1         0             0
 *                            ┗━━┓
 *                               0
 *
 *       4) RL 형식 : X의 오른쪽 자식의 왼쪽에 삽입하는 경우
 *          - 회전 조건
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                     -1                      0
 *                      ┗━━━━━┓         ┏━━━━━┛ ┗━━━━━┓
 *                            0         0             0
 *
 *                                 1
 *                      ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                     -2                      0
 *                      ┗━━━━━┓         ┏━━━━━┛ ┗━━━━━┓
 *                           -1         0             0
 *                         ┏━━┛
 *                         0
 * 3. AVL트리의 높이
 *    ; 각 노드는 '균형 인수'를 계산하기 위한 목적으로 자신의 '높이(Height)'값을 가진다.
 */
#include <stdio.h>
#include <stdlib.h>

int getMax(int a, int b) {
    if(a > b) return a;
    return b;
}

//트리의 정의
typedef struct {
    int data;
    int height;  // 높이를 저장해야 시간 복잡도를 보장할 수 있음.
    struct Node* leftChild;
    struct Node* rightChild;
} Node;

//AVL 트리의 높이 계산 함수
int getHeight(Node* node) {
    if(node==NULL) return 0;
    return node->height;
}

//모든 노드는 회전을 수행한 이후에 높이를 다시 계산
void setHeight(Node* node) {
    node->height = getMax(getHeight(node->leftChild), getHeight(node->rightChild)) + 1;
}

int getDifference(Node* node) {
    if(node==NULL) return 0;
    Node* leftChild = node->leftChild;
    Node* rightChild = node->rightChild;
    return getHeight(leftChild) - getHeight(rightChild);
}

/*
 * LL 회전
 *    - 불균형 발생
 *      ; L 영역에 새로운 노드가 삽입되는 경우 노드 X를 기준으로 했을 때 불균형이 발생했다.
 *                           2                                                  X
 *                ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓                           ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                X                      0                           L                      0
 *         ┏━━━━━┛ ┗━━━━━┓        ┏━━━━━┛ ┗━━━━━┓             ┏━━━━━┛ ┗━━━━━┓        ┏━━━━━┛ ┗━━━━━┓
 *         L             0        0             0             1             0        0             0
 *     ┏━━┛ ┗━━┓                                          ┏━━┛ ┗━━┓
 *     1       0                                          1       0
 *    ┏┛                                                 ┏┛
 *    0                                                  0
 *    - LL 회전
 *      ; 노드 X를 기준으로 LL 회전을 수행하여 트리의 불균형을 해소한다.
 *                           1                                                L
 *                ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓                         ┏━━━━━━━━━┛ ┗━━━━━━━━━━┓
 *                L                      0                         1                      X
 *         ┏━━━━━┛ ┗━━━━━┓        ┏━━━━━┛ ┗━━━━━┓           ┏━━━━━┛ ┗━━━━━┓        ┏━━━━━┛ ┗━━━━━┓
 *         1             X        0             0           1             0        0             0
 *      ┏━━┛         ┏━━┛ ┗━━┓                           ┏━━┛                                ┏━━┛ ┗━━┓
 *      0            0       0                           0                                   0       0
 */
// AVL 트리의 LL 회전
Node* rotateLL(Node* node) {
    Node* leftChild = node->leftChild;
    node->leftChild = leftChild->rightChild;
    leftChild->rightChild = node;
    setHeight(node); // 회전 이후에 높이를 다시 계산
    return leftChild;
}