//
// Created by invin on 2020-02-24.
//
/*
 * 자료구조(Data Structure)
 * 1. 데이터를 효과적으로 저장하고, 처리하는 방법에 대해서 바르게 이해할 필요가 있다.
 * 2. 자료구조를 제대로 이해하지 못하면 불필요하게 메모리와 성능을 낭비할 여지가 있다.
 *    1) 필요성
 *       - 프로그램 내에서 int형 데이터가 100만 개 가량이 사용된다고 가정
 *       - 이때 원하는 데이터를 가장 빠르게 찾도록 해주는 자료구조는 무엇인가?
 * 3. 기본적인 자료구조들
 *    1) 선형구조 : 배열(Array), 연결리스트(Linked List), 스택(Stack), 큐(Queue)
 *    2) 비선형구조 : 트리(Tree), 그래프(Graph)
 * 4. 자료구조와 알고리즘
 *    1) 효울적인 자료구조 설계를 위해 알고리즘 지식이 필요하다.
 *    2) 효율적인 알고리즘을 작성하기 위해서는 문제 상황에 맞는 적절한 자료구조가 사용되어야 한다.
 *    3) 따라서 자료구조론과 알고리즘 이론은 모두 동일선상에 놓을 수 있다.
 * 5. 프로그램의 성능 측정 방법론
 *    1) 시간 복잡도(Time Complexity)란 알고리즘에 사용되는 연산 횟수를 의미
 *       - 표현법은 최악의 경우를 나타내는 Big-O 표기법을 사용
 *       - 시간 복잡도를 표기할 때는 항상 큰 항과 계수만 표시한다.
 *         O(3n^2+n) = O(n^2)
 *    2) 공간 복잡도(Space Complexity)란 알고리즘에 사용되는 메모리의 양을 의미
 *       - 공간 복잡도를 표기할 때는 일반적으로 MB 단위로 표기한다.
 *          int a[1000] : 4kb
 *          int a[1000000] : 4mb
 *          int a[2000][2000] : 16mb
 *       *** 효율적인 알고리즘을 사용한다고 가정했을때 일반적으로 시간과 공간은 반비례 관계이다.
 *
 */
#include <stdio.h>
#include <iostream>

using namespace std;

int main(void) {
    // 5. 성능 측정 방법론 - 시간복잡도
    // O(n)의 시간복잡도
    int a, b;
    cin >> a >> b;
    int sum = 1;
    for(int i=0; i<b; i++) {
        sum *= a;
    }
    cout << sum;

    //O(n^2)의 시간복잡도
    int n;
    cin >> n;
    for(int i=0; i<n; i++) {
        for(int j=0; j<=i; j++) {
            cout << "*";
        }
        cout << '\n';
    }

    // 3의 시간 복잡도
    int c, d;
    cin >> c >> d;
    cout << c + d;

    /*
     * [예시] n이 1,000일 때?
     * n : 1,000번의 연산
     * n log n : 약 10,000번의 연산
     * n^2 : 1,000,000번의 연산
     * n^3 : 1,000,000,000번의 연산
     * *** 보통 연산 횟수가 10억을 넘어가면 1초 이상의 시간이 소요된다.
     */
}