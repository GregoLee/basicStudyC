//
// Created by Jaeyoung Lee on 2020/03/05.
//
/*
 * 기수 정렬(Radix Sort)
 * 1. 개요
 *    1) 자릿수를 기준으로 차례대로 데이터를 정렬하는 알고리즘
 *    2) 자릿수를 기준으로 분류하므로 가장 큰 자릿수를 D라고 했을 때 O(DN)의 시간 복잡도를 가진다.
 * 2. 적용법
 *                  0 1 2 3 4 5 6 7 8 9      원소    |  7| 25| 30| 34|341| 65| 84|
 *     1 자릿수 배열   1 1 0 0 2 2 0 1 0 0
 *                            ↓
 *     1 자릿수(누적)  1 2 0 0 4 6 0 7 0 0
 *
 *                  1) 원소를 역순으로 순회한다.
 *                  2) 1자릿수가 동일한 원소를 누적에 표시된 값대로 해당 순서에 배치
 *                  3) 누적치를 1 차감한다.
 *
 *                  0 1 2 3 4 5 6 7 8 9
 *     1 자릿수(누적)  1 2 0 0 4 6 0 7 0 0      원소    |  7| 25| 30| 34|341| 65| 84|
 *                          3              84 이동   |   |   |   | 84|   |   |   |
 *                            5            65 이동   |   |   |   | 84|   | 65|   |
 *                    1                   341 이동   |   |341|   | 84|   | 65|   |
 *                          2              34 이동   |   |341| 34| 84|   | 65|   |
 *                  0                      30 이동   | 30|341| 34| 84|   | 65|   |
 *                            4            25 이동   | 30|341| 34| 84| 25| 65|   |
 *                                6         7 이동   | 30|341| 34| 84| 25| 65|  7|
 *
 *                  0 1 2 3 4 5 6 7 8 9
 *    10 자릿수(누적)  1 0 2 4 5 0 6 0 7 0      원소    | 30|341| 34| 84| 25| 65|  7|
 *                  0                       7 이동   |  7|   |   |   |   |   |   |
 *                              5          65 이동   |  7|   |   |   |   | 65|   |
 *                      1                  25 이동   |  7| 25|   |   |   | 65|   |
 *                                  6      84 이동   |  7| 25|   |   |   | 65| 84|
 *                        3                34 이동   |  7| 25|   | 34|   | 65| 84|
 *                          4             341 이동   |  7| 25|   | 34|341| 65| 84|
 *                        2                30 이동   |  7| 25| 30| 34|341| 65| 84|
 *
 *                  0 1 2 3 4 5 6 7 8 9
 *   100 자릿수(누적)  6 0 0 7 0 0 0 0 0 0      원소    |  7| 25| 30| 34|341| 65| 84|
 *                  5                      84 이동   |   |   |   |   |   | 84|   |
 *                  4                      65 이동   |   |   |   |   | 65| 84|   |
 *                        6               341 이동   |   |   |   |   | 65| 84|341|
 *                  3                      34 이동   |   |   |   | 34| 65| 84|341|
 *                  2                      30 이동   |   |   | 30| 34| 65| 84|341|
 *                  1                      25 이동   |   | 25| 30| 34| 65| 84|341|
 *                  0                      25 이동   |  7| 25| 30| 34| 65| 84|341|
 */
#include <stdio.h>
#include <limits.h>

void radixSort(int *a, int n) {
    int maxValue = INT_MIN, radix = 1, result[n];
    for(int i=0; i<n; i++) {
        if(a[i]>maxValue) maxValue = a[i];
    }
    while(maxValue/radix > 0) {
        int b[10] = { 0 };
        for(int i=0; i<n; i++) { b[a[i] / radix % 10]++; } // 자릿수 갯수 세기
        for(int i=1; i<10; i++) { b[i] += b[i-1]; } // 누적 계산
        for(int i=n-1; i>=0; i--) { result[--b[a[i] / radix % 10]] = a[i]; } // 같은 자릿수 정렬
        for(int i=0; i<n; i++) a[i] = result[i]; // 배열 복사
        radix *= 10;
    }
}

int main(void) {
    int n;
    scanf("%d", &n);
    int *b = (int*)malloc(sizeof(int)*n);
    for(int i=0; i<n; i++) {
        scanf("%d", b+i);
    }
    for(int i=0; i<n; i++) printf("%d ", b[i]);
    printf("\n");
    radixSort(b, n);
    for(int i=0; i<n; i++) printf("%d ", b[i]);
    return 0;
}